from typing import Dict, Iterable, Tuple, TypeVar, TYPE_CHECKING

if TYPE_CHECKING:
  from .diorama import Diorama

T = TypeVar('T')

from .hazards import Hazard
from .position import Position
from .tile import Tile
from lib.version import VERSION

def serialize(diorama: 'Diorama') -> str:
  return '\n'.join(_serialize(diorama))


def _serialize(diorama: 'Diorama') -> Iterable[str]:
  left, top, width, height = diorama.bounds
  eox = width // 2
  eoy = height // 2
  offset = (-left, -top)

  yield 'comments{'
  for c in _comments(diorama):
    yield f'  {c}'
  yield '}'

  yield 'info{'
  yield f'rowcount:{width:d}'
  yield f'colcount:{height:d}'
  yield f'camerapos:{diorama.camera_position.serialize(offset)}'
  yield f'biome:{diorama.context.biome.value}'
  yield 'creator:hognose'
  if diorama.level_name:
    yield f'levelname:{diorama.level_name}'
  yield 'opencaves:' + _tile_coords(
      # Open cave flags are in the form 'y,x/' for some reason.
      sorted((x, y) for (y, x) in diorama.open_cave_flags), (-top, -left))
  yield 'spiderrate:10'
  yield 'spidermin:2'
  yield 'spidermax:4'
  yield 'version:2023-08-14-1'  # The version of MM this is for.
  yield '}'

  yield 'tiles{'
  yield from _tile_grid(
    diorama,
    Tile.SOLID_ROCK.export_value,
    dict(_tile_export_values(diorama)))
  yield '}'

  yield 'height{'
  for _ in range(height + 1):
    yield ''.join('0,' * (width + 1))
  yield '}'

  yield 'resources{'
  yield 'crystals:'
  yield from _tile_grid(diorama, 0, diorama.crystals)
  yield 'ore:'
  yield from _tile_grid(diorama, 0, diorama.ore)
  yield '}'

  yield 'objectives{'
  for o in diorama.objectives:
    yield o.serialize()
  yield '}'

  yield 'buildings{'
  for b in diorama.buildings:
    yield b.serialize(offset)
  yield '}'

  yield 'landslidefrequency{'
  yield from _hazard(diorama.landslides.items(), offset)
  yield '}'
  yield 'lavaspread{'
  yield from _hazard(diorama.erosions.items(), offset)
  yield '}'

  yield 'creatures{'
  for c in diorama.creatures:
    yield c.serialize(offset)
  yield '}'
  yield 'miners{'
  for m in diorama.miners:
    yield m.serialize(offset)
  yield '}'

  yield 'briefing{'
  yield diorama.briefing
  yield '}'
  yield 'briefingsuccess{'
  yield diorama.briefing_success
  yield '}'
  yield 'briefingfailure{'
  yield diorama.briefing_failure
  yield '}'

  yield 'vehicles{'
  yield '}'
  yield 'blocks{'
  yield '}'
  yield 'script{'
  yield diorama.script.serialize(offset)
  yield '}'


def _comments(diorama: 'Diorama') -> Iterable[str]:
  yield f'Cavern generated by Hognose v{VERSION}'
  yield 'https://github.com/charredUtensil/hognose'
  yield from str(diorama.context).splitlines()


def _hazard(
    hazards: Iterable[Tuple[Tuple[int, int], Hazard]],
    offset: Tuple[int, int]):
  """Yields data for landslides or erosions."""
  out = {}
  for (x, y), h in hazards:
    key = h.serial_key
    if key not in out:
      out[key] = []
    out[key].append((x, y))
  for key, coords in sorted(out.items(), reverse=True):
    key_str = '/'.join(f'{k:0.1f}' for k in key)
    yield f'{key_str}:{_tile_coords(coords, offset)}'


def _tile_export_values(
    diorama: 'Diorama') -> Iterable[Tuple[Tuple[int, int], int]]:
  """Yields the correct export value for all tiles, considering discovery."""
  for coord, tile in diorama.tiles.items():
    v = tile.export_value
    if not tile.is_wall and coord not in diorama._discovered:
      v += 100
    yield coord, v


def _tile_coords(
    coords: Iterable[Tuple[int, int]],
    offset: Tuple[int, int]) -> str:
  """Yields tile coordinate data for anything that uses 'x,y/' format."""
  ox, oy = offset
  return ''.join(f'{x + ox :d},{y + oy :d}/' for x, y in coords)


def _tile_grid(
    diorama: 'Diorama',
    default: T,
    grid: Dict[Tuple[int, int], T]) -> Iterable[str]:
  """Yields the tile-grid for tile, ore, and crystal sections."""
  left, top, width, height = diorama.bounds
  for y in range(top, top + height):
    yield ''.join(
      f'{grid.get((x, y), default)},'
      for x in range(left, left + width))
